@startuml
namespace sameriver {
    class AddRemoveLogicEvent << (S,Aquamarine) >> {
        - addRemove bool
        - runnerName string
        - l *LogicUnit

    }
    class AudioManager << (S,Aquamarine) >> {
        - audio <font color=blue>map</font>[string]

        + Init() 
        + Load(file string) 
        + Play(file string) 

    }
    class Blackboard << (S,Aquamarine) >> {
        + Name string
        + State <font color=blue>map</font>[string]<font color=blue>interface</font>{}
        + Events *EventBus

    }
    class CollisionData << (S,Aquamarine) >> {
        + This *Entity
        + Other *Entity

    }
    class CollisionRateLimiterArray << (S,Aquamarine) >> {
        - capacity int
        - delay time.Duration
        - backingArr []atomic.Uint32
        - arr [][]atomic.Uint32

        + GetRateLimiter(i int, j int) *atomic.Uint32
        + Do(i int, j int, f <font color=blue>func</font>() ) 
        + Reset(e *Entity) 
        + Expand(n int) 

    }
    class CollisionSystem << (S,Aquamarine) >> {
        - w *World
        - collidableEntities *UpdatedEntityList
        - rateLimiterArray CollisionRateLimiterArray
        - delay time.Duration
        - sh *SpatialHashSystem

        - checkEntities(entities []*Entity) 

        + DoCollide(i *Entity, j *Entity) 
        + TestCollision(i *Entity, j *Entity) bool
        + GetComponentDeps() []string
        + LinkWorld(w *World) 
        + Update(dt_ms float64) 
        + UpdateParallel(dt_ms float64) 
        + Expand(n int) 

    }
    class ComponentSet << (S,Aquamarine) >> {
        - names <font color=blue>map</font>[string]bool
        - vec2DMap <font color=blue>map</font>[string]Vec2D
        - boolMap <font color=blue>map</font>[string]bool
        - intMap <font color=blue>map</font>[string]int
        - float64Map <font color=blue>map</font>[string]float64
        - timeMap <font color=blue>map</font>[string]time.Time
        - timeAccumulatorMap <font color=blue>map</font>[string]TimeAccumulator
        - stringMap <font color=blue>map</font>[string]string
        - spriteMap <font color=blue>map</font>[string]Sprite
        - tagListMap <font color=blue>map</font>[string]TagList
        - intMapMap <font color=blue>map</font>[string]IntMap
        - floatMapMap <font color=blue>map</font>[string]FloatMap
        - genericMap <font color=blue>map</font>[string]any
        - customComponentsMap <font color=blue>map</font>[string]any
        - customComponentsImpl <font color=blue>map</font>[string]CustomContiguousComponent

    }
    class ComponentTable << (S,Aquamarine) >> {
        - capacity int
        - nextIx int
        - ixs <font color=blue>map</font>[string]int
        - ixsRev <font color=blue>map</font>[int]string
        - names <font color=blue>map</font>[string]bool
        - kinds <font color=blue>map</font>[string]string
        - vec2DMap <font color=blue>map</font>[string][]Vec2D
        - boolMap <font color=blue>map</font>[string][]bool
        - intMap <font color=blue>map</font>[string][]int
        - float64Map <font color=blue>map</font>[string][]float64
        - timeMap <font color=blue>map</font>[string][]time.Time
        - timeAccumulatorMap <font color=blue>map</font>[string][]TimeAccumulator
        - stringMap <font color=blue>map</font>[string][]string
        - spriteMap <font color=blue>map</font>[string][]Sprite
        - tagListMap <font color=blue>map</font>[string][]TagList
        - intMapMap <font color=blue>map</font>[string][]IntMap
        - floatMapMap <font color=blue>map</font>[string][]FloatMap
        - genericMap <font color=blue>map</font>[string][]<font color=blue>interface</font>{}
        - cccMap <font color=blue>map</font>[string]CustomContiguousComponent

        - expand(n int) 
        - nameAndIndex(name string) 
        - addComponent(kind string, name string) 
        - applyComponentSet(e *Entity, cs ComponentSet) 
        - bitArrayFromComponentSet(cs ComponentSet) bitarray.BitArray
        - guardInvalidComponentGet(e *Entity, name string) 

        + ComponentExists(name string) bool
        + AddCCC(custom CustomContiguousComponent) 
        + AssertValidComponentSet(cs ComponentSet) 
        + ApplyComponentSet(e *Entity, spec <font color=blue>map</font>[string]any) 
        + BitArrayFromNames(names []string) bitarray.BitArray
        + BitArrayFromComponentSet(spec <font color=blue>map</font>[string]any) bitarray.BitArray
        + BitArrayToString(b bitarray.BitArray) string

    }
    interface CustomContiguousComponent  {
        + Name() string
        + AllocateTable(n int) 
        + ExpandTable(n int) 
        + Get(e *Entity) <font color=blue>interface</font>{}
        + Set(e *Entity, x <font color=blue>interface</font>{}) 

    }
    class DespawnRequestData << (S,Aquamarine) >> {
        + Entity *Entity

    }
    class Entity << (S,Aquamarine) >> {
        - funcs *FuncSet
        - mind <font color=blue>map</font>[string]<font color=blue>interface</font>{}

        + ID int
        + World *World
        + Active bool
        + Despawned bool
        + ComponentBitArray bitarray.BitArray
        + Lists []*UpdatedEntityList
        + Logics <font color=blue>map</font>[string]*LogicUnit

        - makeLogicUnit(name string, F <font color=blue>func</font>(float64) ) *LogicUnit

        + GetVec2D(name string) *Vec2D
        + GetBool(name string) *bool
        + GetInt(name string) *int
        + GetFloat64(name string) *float64
        + GetTime(name string) *time.Time
        + GetTimeAccumulator(name string) *TimeAccumulator
        + GetString(name string) *string
        + GetSprite(name string) *Sprite
        + GetTagList(name string) *TagList
        + GetIntMap(name string) *IntMap
        + GetFloatMap(name string) *FloatMap
        + GetGeneric(name string) <font color=blue>interface</font>{}
        + SetGeneric(name string, val <font color=blue>interface</font>{}) 
        + GetVal(name string) <font color=blue>interface</font>{}
        + GetCustom(name string) <font color=blue>interface</font>{}
        + SetCustom(name string, x <font color=blue>interface</font>{}) 
        + LogicUnitName(name string) string
        + AddLogic(name string, F <font color=blue>func</font>(*Entity, float64) ) *LogicUnit
        + AddLogicWithSchedule(name string, F <font color=blue>func</font>(*Entity, float64) , period float64) *LogicUnit
        + RemoveLogic(name string) 
        + RemoveAllLogics() 
        + ActivateLogics() 
        + DeactivateLogics() 
        + AddFuncs(funcs <font color=blue>map</font>[string]) 
        + AddFunc(name string, f <font color=blue>func</font>(*Entity, any) any) 
        + RemoveFunc(name string) 
        + HasFunc(name string) bool
        + GetMind(name string) <font color=blue>interface</font>{}
        + SetMind(name string, val <font color=blue>interface</font>{}) 
        + String() string

    }
    class EntityFilter << (S,Aquamarine) >> {
        + Name string
        + Predicate <font color=blue>func</font>(*Entity) bool

        + Test(e *Entity) bool

    }
    class EntityIDAllocator << (S,Aquamarine) >> {
        - availableIDs []int
        - currentEntities <font color=blue>map</font>[*Entity]bool
        - active int
        - capacity int

        + IdGen *IDGenerator

        - expand(n int) 
        - allocateID() *Entity
        - deallocate(e *Entity) 

    }
    class EntityManager << (S,Aquamarine) >> {
        - w *World
        - components *ComponentTable
        - entityIDAllocator *EntityIDAllocator
        - lists <font color=blue>map</font>[string]*UpdatedEntityList
        - entitiesWithTag <font color=blue>map</font>[string]*UpdatedEntityList
        - uniqueEntities <font color=blue>map</font>[string]*Entity
        - activeEntities <font color=blue>map</font>[*Entity]bool
        - spawnSubscription *EventChannel
        - despawnSubscription *EventChannel

        - setActiveState(e *Entity, state bool) 
        - createEntitiesWithTagListIfNeeded(tag string) 
        - processDespawnChannel() 
        - getUpdatedEntityList(q EntityFilter, sorted bool) *UpdatedEntityList
        - notifyActiveState(e *Entity, active bool) 
        - checkActiveEntity(e *Entity) 
        - processSpawnChannel() 
        - doSpawn(active bool, uniqueTag string, tags []string, components ComponentSet, logics <font color=blue>map</font>[string], funcs <font color=blue>map</font>[string], mind <font color=blue>map</font>[string]any) *Entity

        + Components() *ComponentTable
        + Update(allowance_ms float64) float64
        + Activate(e *Entity) 
        + Deactivate(e *Entity) 
        + UniqueTaggedEntity(tag string) (*Entity, error)
        + UpdatedEntitiesWithTag(tag string) *UpdatedEntityList
        + EntityHasComponent(e *Entity, name string) bool
        + EntityHasTag(e *Entity, tag string) bool
        + TagEntity(e *Entity, tags ...string) 
        + TagEntities(entities []*Entity, tag string) 
        + UntagEntity(e *Entity, tag string) 
        + UntagEntities(entities []*Entity, tag string) 
        + MaxEntities() int
        + NumEntities() (int, int)
        + GetActiveEntitiesSet() <font color=blue>map</font>[*Entity]bool
        + GetCurrentEntitiesSet() <font color=blue>map</font>[*Entity]bool
        + GetCurrentEntitiesSetCopy() <font color=blue>map</font>[*Entity]bool
        + String() string
        + DumpEntities() string
        + DespawnAll() 
        + Despawn(e *Entity) 
        + QueueDespawn(e *Entity) 
        + GetUpdatedEntityList(q EntityFilter) *UpdatedEntityList
        + GetSortedUpdatedEntityList(q EntityFilter) *UpdatedEntityList
        + GetUpdatedEntityListByName(name string) *UpdatedEntityList
        + GetUpdatedEntityListByComponentNames(names []string) *UpdatedEntityList
        + Spawn(spec <font color=blue>map</font>[string]any) *Entity
        + QueueSpawn(spec <font color=blue>map</font>[string]any) 
        + ExpandEntityTables() 

    }
    interface EntityManagerInterface  {
        + Update(allowance_ms float64) float64
        + MaxEntities() int
        + Components() *ComponentTable
        + Spawn(spec <font color=blue>map</font>[string]any) *Entity
        + QueueSpawn(spec <font color=blue>map</font>[string]any) 
        + Despawn(e *Entity) 
        + QueueDespawn(e *Entity) 
        + DespawnAll() 
        + Activate(e *Entity) 
        + Deactivate(e *Entity) 
        + TagEntity(e *Entity, tags ...string) 
        + TagEntities(entities []*Entity, tag string) 
        + UntagEntity(e *Entity, tag string) 
        + UntagEntities(entities []*Entity, tag string) 
        + NumEntities() (int, int)
        + GetActiveEntitiesSet() <font color=blue>map</font>[*Entity]bool
        + GetCurrentEntitiesSet() <font color=blue>map</font>[*Entity]bool
        + GetCurrentEntitiesSetCopy() <font color=blue>map</font>[*Entity]bool
        + UniqueTaggedEntity(tag string) (*Entity, error)
        + UpdatedEntitiesWithTag(tag string) *UpdatedEntityList
        + EntityHasComponent(e *Entity, name string) bool
        + EntityHasTag(e *Entity, tag string) bool
        + GetUpdatedEntityList(q EntityFilter) *UpdatedEntityList
        + GetSortedUpdatedEntityList(q EntityFilter) *UpdatedEntityList
        + GetUpdatedEntityListByName(name string) *UpdatedEntityList
        + GetUpdatedEntityListByComponentNames(names []string) *UpdatedEntityList
        + String() string
        + DumpEntities() string

    }
    class EntitySignal << (S,Aquamarine) >> {
        + SignalType EntitySignalType
        + Entity *Entity

    }
    class Event << (S,Aquamarine) >> {
        + Type string
        + Data <font color=blue>interface</font>{}

    }
    class EventBus << (S,Aquamarine) >> {
        - subscriberList SubscriberList
        - nHanging atomic.Int32

        - notifySubscribers(e Event) 

        + Publish(t string, data <font color=blue>interface</font>{}) 
        + Subscribe(q *EventFilter) *EventChannel
        + Unsubscribe(c *EventChannel) 

    }
    class EventChannel << (S,Aquamarine) >> {
        - active *atomic.Uint32
        - filter *EventFilter

        + C <font color=blue>chan</font> Event

        + Activate() 
        + Deactivate() 
        + IsActive() bool
        + DrainChannel() 

    }
    class EventFilter << (S,Aquamarine) >> {
        - eventType string
        - predicate <font color=blue>func</font>(Event) bool

        + Test(e Event) bool

    }
    class FixedScreenMessage << (S,Aquamarine) >> {
        + Msg string
        + Lines int
        + Age int

    }
    class FloatMap << (S,Aquamarine) >> {
        - m <font color=blue>map</font>[string]float64

        + CopyOf() FloatMap

    }
    class FloatingScreenMessage << (S,Aquamarine) >> {
        + Msg string
        + Position []int
        + Duration int
        + Age int

    }
    class FuncSet << (S,Aquamarine) >> {
        - funcs <font color=blue>map</font>[string]

        + Add(name string, f <font color=blue>func</font>(any) any) 
        + Remove(name string) 
        + Has(name string) bool

    }
    class GOAPAction << (S,Aquamarine) >> {
        - parent *GOAPAction
        - insertionIx int
        - regionIx int
        - spec <font color=blue>map</font>[string]any
        - cost IntOrFunc
        - pres *GOAPTemporalGoal
        - preModalChecks <font color=blue>map</font>[string]<font color=blue>func</font>(*GOAPWorldState) int
        - effModalSetters <font color=blue>map</font>[string]<font color=blue>func</font>(*GOAPWorldState, string, int) 
        - effs <font color=blue>map</font>[string]*GOAPEff
        - ops <font color=blue>map</font>[string]string

        + Name string
        + Count int

        + DisplayName() string
        + CopyOf() *GOAPAction
        + Parametrized(n int) *GOAPAction
        + ChildOf(p *GOAPAction) *GOAPAction

    }
    class GOAPActionSet << (S,Aquamarine) >> {
        - set <font color=blue>map</font>[string]*GOAPAction

        + Add(actions ...*GOAPAction) 

    }
    class GOAPEff << (S,Aquamarine) >> {
        - val int
        - op string
        - f <font color=blue>func</font>(int, int) int

    }
    class GOAPEvaluator << (S,Aquamarine) >> {
        - modalVals <font color=blue>map</font>[string]GOAPModalVal
        - actions *GOAPActionSet
        - varActions <font color=blue>map</font>[string]

        - checkModalInto(varName string, ws *GOAPWorldState) 
        - actionAffectsVar(action *GOAPAction, varName string) 
        - applyActionBasic(action *GOAPAction, ws *GOAPWorldState, makeCopy bool) *GOAPWorldState
        - applyActionModal(action *GOAPAction, ws *GOAPWorldState) *GOAPWorldState
        - computeRemainingsOfPath(path *GOAPPath, start *GOAPWorldState, main *GOAPTemporalGoal) 
        - presFulfilled(a *GOAPAction, ws *GOAPWorldState) bool
        - validateForward(path *GOAPPath, start *GOAPWorldState, main *GOAPTemporalGoal) bool
        - actionHelpsToInsert(start *GOAPWorldState, path *GOAPPath, insertionIx int, goalToHelp *GOAPGoalRemaining, action *GOAPAction) (int, bool)

        + AddModalVals(vals ...GOAPModalVal) 
        + AddActions(actions ...*GOAPAction) 

    }
    class GOAPGoal << (S,Aquamarine) >> {
        - spec <font color=blue>map</font>[string]int
        - vars <font color=blue>map</font>[string]*NumericInterval

        - remaining(ws *GOAPWorldState) *GOAPGoalRemaining

        + Parametrized(n int) *GOAPGoal

    }
    class GOAPGoalRemaining << (S,Aquamarine) >> {
        - goal *GOAPGoal
        - goalLeft <font color=blue>map</font>[string]*NumericInterval
        - diffs <font color=blue>map</font>[string]float64
        - nUnfulfilled int

    }
    class GOAPGoalRemainingSurface << (S,Aquamarine) >> {
        - surface [][]*GOAPGoalRemaining

        - nUnfulfilledAtIx(i int) int

        + NUnfulfilled() int

    }
    class GOAPModalVal << (S,Aquamarine) >> {
        - name string
        - check <font color=blue>func</font>(*GOAPWorldState) int
        - effModalSet <font color=blue>func</font>(*GOAPWorldState, string, int) 

    }
    class GOAPPQueueItem << (S,Aquamarine) >> {
        - path *GOAPPath
        - index int

    }
    class GOAPPath << (S,Aquamarine) >> {
        - path []*GOAPAction
        - cost int
        - statesAlong []*GOAPWorldState
        - remainings *GOAPGoalRemainingSurface
        - regionOffsets [][]int

        - costOfAdd(a *GOAPAction) int
        - inserted(a *GOAPAction, insertionIx int, regionIx int) *GOAPPath

        + String() string

    }
    class GOAPPlanner << (S,Aquamarine) >> {
        - e *Entity
        - eval *GOAPEvaluator

        - traverseFulfillers(pq *GOAPPriorityQueue, start *GOAPWorldState, here *GOAPPQueueItem, goal *GOAPTemporalGoal, pathsSeen <font color=blue>map</font>[string]bool) 

        + Plan(start *GOAPWorldState, goalSpec any, maxIter int) (*GOAPPath, bool)

    }
    class GOAPPriorityQueue << (S,Aquamarine) >> {
        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 
        + Push(x any) 
        + Pop() any

    }
    class GOAPTemporalGoal << (S,Aquamarine) >> {
        - temporalGoals []*GOAPGoal

        + Parametrized(n int) *GOAPTemporalGoal

    }
    class GOAPWorldState << (S,Aquamarine) >> {
        - vals <font color=blue>map</font>[string]int
        - modal <font color=blue>map</font>[string]<font color=blue>interface</font>{}

        - ecKey(e *Entity, name string) string

        + CopyOf() *GOAPWorldState
        + GetModal(e *Entity, name string) <font color=blue>interface</font>{}
        + SetModal(e *Entity, name string, val <font color=blue>interface</font>{}) 

    }
    class Game << (S,Aquamarine) >> {
        - running bool
        - loadingScene Scene
        - currentScene Scene
        - endScene <font color=blue>chan</font> bool

        + Window *sdl.Window
        + Renderer *sdl.Renderer
        + WindowSpec WindowSpec
        + Screen GameScreen

        - run() 
        - blankScreen() 
        - handleKeyboard(scene Scene) 

        + SetLoadingScene(scene Scene) 
        + RunScene(scene Scene, endScene <font color=blue>chan</font> bool) Scene
        + GoEndGame() 
        + Destroy() 

    }
    class GameInitSpec << (S,Aquamarine) >> {
        + WindowSpec WindowSpec
        + LoadingScene Scene
        + FirstScene Scene

    }
    class GameScreen << (S,Aquamarine) >> {
        + W int
        + H int

        + ScreenSpaceY(y int) int
        + ScreenSpaceRect(pos *Vec2D, box *Vec2D) *sdl.Rect
        + DrawRect(r *sdl.Renderer, pos *Vec2D, box *Vec2D) 
        + FillRect(r *sdl.Renderer, pos *Vec2D, box *Vec2D) 

    }
    class IDGenerator << (S,Aquamarine) >> {
        - universe <font color=blue>map</font>[int]bool
        - freed <font color=blue>map</font>[int]bool
        - x atomic.Uint32

        + Next() int
        + Free(ID int) 

    }
    class IntMap << (S,Aquamarine) >> {
        - m <font color=blue>map</font>[string]int

        + CopyOf() IntMap

    }
    interface IntOrFunc  {
    }
    class Inventory << (S,Aquamarine) >> {
        + Stacks []*Item

        - setCount(n int, filtered []*Item) 

        + CopyOf() *Inventory
        + ItemsForDisplay() []*Item
        + StacksForDisplay() []*Item
        + Delete(stack *Item) 
        + DebitWithPreference(stack *Item, leastOrMostDegraded int) *Item
        + Debit(stack *Item) *Item
        + DebitNWithPreference(n int, stack *Item, leastOrMostDegraded int) *Item
        + DebitN(n int, stack *Item) *Item
        + DebitAll(stack *Item) *Item
        + DebitByFilter(predicate <font color=blue>func</font>(*Item) bool) []*Item
        + DebitNByFilter(n int, predicate <font color=blue>func</font>(*Item) bool) []*Item
        + DebitAllFilter(predicate <font color=blue>func</font>(*Item) bool) []*Item
        + DebitTags(tags ...string) *Item
        + DebitNTags(n int, tags ...string) []*Item
        + DebitAllTags(tags ...string) []*Item
        + Credit(stack *Item) 
        + GetNByName(inv *Inventory, n int, name string) 
        + GetNByFilter(inv *Inventory, n int, predicate <font color=blue>func</font>(*Item) bool) 
        + GetAllByName(inv *Inventory, name string) 
        + GetAllByFilter(inv *Inventory, predicate <font color=blue>func</font>(*Item) bool) 
        + GetAll(inv *Inventory) 
        + SetCountName(n int, archetype string) 
        + SetCountTags(n int, tags ...string) 
        + CountName(name string) int
        + Count(predicate <font color=blue>func</font>(*Item) bool) int
        + CountTags(tags ...string) int
        + Filter(predicate <font color=blue>func</font>(*Item) bool) []*Item
        + FilterTags(tags ...string) []*Item
        + ContainsName(name string) bool
        + Contains(predicate <font color=blue>func</font>(*Item) bool) bool
        + FilterName(name string) []*Item
        + String() string

    }
    class InventorySystem << (S,Aquamarine) >> {
        - itemSystem *ItemSystem

        + InventoryEntities *UpdatedEntityList

        + Create(listing <font color=blue>map</font>[string]int) *Inventory
        + GetComponentDeps() []string
        + LinkWorld(w *World) 
        + Update(dt_ms float64) 
        + Expand(n int) 

    }
    class Item << (S,Aquamarine) >> {
        - sys *ItemSystem
        - inv *Inventory
        - degradationRate float64
        - propertiesForDisplayDirty bool
        - propertiesForDisplay []string

        + Archetype string
        + DisplayStr string
        + Properties <font color=blue>map</font>[string]float64
        + Tags TagList
        + Count int
        + Degradations []float64

        - propertiesAndTagsMatch(other *Item) bool
        - reevaluateDisplayStr() 

        + CopyOf() *Item
        + GetArchetype() *ItemArchetype
        + SetProperty(k string, v float64) 
        + GetProperty(k string) float64
        + DebitStack(n int, leastOrMostDegraded int) *Item
        + CreditStack(stack *Item) 
        + SetCount(n int) 
        + PropertiesForDisplay() []string
        + HasProperty(k string) bool
        + DisplayName() string
        + TagsForDisplay() []string
        + String() string

    }
    class ItemArchetype << (S,Aquamarine) >> {
        + Name string
        + DisplayName string
        + FlavourText string
        + Properties <font color=blue>map</font>[string]float64
        + Tags TagList
        + Entity <font color=blue>map</font>[string]any

        + String() string

    }
    class ItemSystem << (S,Aquamarine) >> {
        - w *World
        - inventorySystem *InventorySystem
        - spriteSystem *SpriteSystem
        - despawn_ms *float64
        - degradation_accum_ms float64
        - spawn bool
        - sprite bool
        - defaultEntityBox Vec2D

        + ItemEntities *UpdatedEntityList
        + Archetypes <font color=blue>map</font>[string]*ItemArchetype

        - registerArchetype(arch *ItemArchetype) 

        + CreateArchetype(spec <font color=blue>map</font>[string]any) 
        + CreateSubArchetype(spec <font color=blue>map</font>[string]any) 
        + CreateItem(spec <font color=blue>map</font>[string]any) *Item
        + CreateStack(n int, spec <font color=blue>map</font>[string]any) *Item
        + CreateItemSimple(archetype string) *Item
        + CreateStackSimple(n int, archetype string) *Item
        + SpawnItemEntity(pos Vec2D, item *Item) *Entity
        + LoadArchetypesFile(filename string) 
        + LoadArchetypesJSON(jsonStr []byte) 
        + UpdateDegradations(dt_ms float64) 
        + GetComponentDeps() []string
        + LinkWorld(w *World) 
        + Update(dt_ms float64) 
        + Expand(n int) 

    }
    class LayeredRenderer << (S,Aquamarine) >> {
        - layers []*RenderLayer
        - names <font color=blue>map</font>[string]*RenderLayer

        + AddLayer(l *RenderLayer) 
        + RemoveLayer(l *RenderLayer) 
        + RemoveLayerByName(name string) 
        + GetLayerByName(name string) *RenderLayer
        + Render(w *sdl.Window, r *sdl.Renderer) float64
        + NumLayers() int

    }
    class LogicUnit << (S,Aquamarine) >> {
        - name string
        - f <font color=blue>func</font>(float64) 
        - active bool
        - worldID int
        - runSchedule *TimeAccumulator
        - hotness int

        + Activate() 
        + Deactivate() 

    }
    class NumericInterval << (S,Aquamarine) >> {
        + A float64

        + Diff(x float64) float64

    }
    class PhysicsSystem << (S,Aquamarine) >> {
        - w *World
        - physicsEntities *UpdatedEntityList

        + GetComponentDeps() []string
        + LinkWorld(w *World) 
        + Update(dt_ms float64) 
        + ParallelUpdate(dt_ms float64) 
        + SingleThreadUpdate(dt_ms float64) 
        + Expand(n int) 

    }
    class Pool << (S,Aquamarine) >> {
        - maker <font color=blue>func</font>() any
        - clearer <font color=blue>func</font>(any) 
        - pool []any
        - capacity int
        - checkOutIxs <font color=blue>map</font>[any]int
        - avail []int
        - dirty <font color=blue>map</font>[int]bool

        + Clear() 
        + Expand(n int) 
        + Checkout() any
        + Return(x any) 
        + Avail() int

    }
    interface Pooled  {
        + New() any
        + Clear( any) 

    }
    class RateLimiter << (S,Aquamarine) >> {
        - limited atomic.Uint32
        - delay time.Duration

        + Do(f <font color=blue>func</font>() ) 
        + Reset() 
        + Limited() bool

    }
    class RenderLayer << (S,Aquamarine) >> {
        - name string
        - z int
        - renderFunc RenderFunc
        - active bool

        + Activate() 
        + Deactivate() 
        + IsActive() bool
        + Name() string
        + Render(w *sdl.Window, r *sdl.Renderer) 

    }
    class RuntimeLimitSharer << (S,Aquamarine) >> {
        - runIX int
        - runners []*RuntimeLimiter
        - runnerMap <font color=blue>map</font>[string]*RuntimeLimiter
        - runnerNames <font color=blue>map</font>[*RuntimeLimiter]string
        - addRemoveChannel <font color=blue>chan</font> AddRemoveLogicEvent
        - innerLoopOverhead_ms float64

        - addLogicImmediately(runnerName string, l *LogicUnit) 
        - removeLogicImmediately(runnerName string, l *LogicUnit) 
        - updateOverhead(worstThisTime float64) 

        + RegisterRunner(name string) *RuntimeLimiter
        + ProcessAddRemoveLogics() 
        + AddLogic(runnerName string, l *LogicUnit) 
        + RemoveLogic(runnerName string, l *LogicUnit) 
        + ActivateAll(runnerName string) 
        + DeactivateAll(runnerName string) 
        + SetSchedule(runnerName string, logicWorldID int, period_ms float64) 
        + Share(allowance_ms float64) (float64, int)
        + DumpStats() <font color=blue>map</font>[string]

    }
    class RuntimeLimiter << (S,Aquamarine) >> {
        - startIx int
        - runIx int
        - finished bool
        - oppIx int
        - logicUnits []*LogicUnit
        - ascendingHotness []*LogicUnit
        - runtimeEstimates <font color=blue>map</font>[*LogicUnit]float64
        - lastRun <font color=blue>map</font>[*LogicUnit]time.Time
        - lastEnd <font color=blue>map</font>[*LogicUnit]time.Time
        - indexes <font color=blue>map</font>[int]int
        - totalRuntime_ms *float64
        - overrun bool
        - ranRobin int
        - ranOpp int
        - starvation float64
        - loopOverhead_ms float64

        - tick(logic *LogicUnit) bool
        - updateOverhead(worstThisTime float64) 
        - normalizeHotness(hot int) 
        - updateEstimate(logic *LogicUnit, elapsed_ms float64) 
        - insertAscendingHotness(logic *LogicUnit) 

        + Run(allowance_ms float64, bonsuTime bool) float64
        + Add(logic *LogicUnit) 
        + Remove(l *LogicUnit) bool
        + ActivateAll() 
        + DeactivateAll() 
        + Finished() bool
        + DumpStats() (<font color=blue>map</font>[string]float64, float64)

    }
    interface Scene  {
        + Name() string
        + Init(game *Game, config <font color=blue>map</font>[string]string) 
        + Update(dt_ms float64, allowance_ms float64) 
        + Draw(window *sdl.Window, renderer *sdl.Renderer) 
        + HandleKeyboardState(keyboard_state []uint8) 
        + HandleKeyboardEvent(keyboard_event *sdl.KeyboardEvent) 
        + IsDone() bool
        + NextScene() Scene
        + End() 
        + IsTransient() bool
        + Destroy() 

    }
    class SceneMap << (S,Aquamarine) >> {
        + Map <font color=blue>map</font>[int]Scene

    }
    interface ScreenMessage  {
        + Position() []int
        + Text() string
        + Update(dt_ms int) 
        + IsActive() bool

    }
    class ScreenMessageManager << (S,Aquamarine) >> {
        - messages <font color=blue>map</font>[int]ScreenMessage

        + Init() 
        + Update(dt_ms int) 

    }
    class SpatialHashSystem << (S,Aquamarine) >> {
        - gridX int
        - gridY int

        + Hasher *SpatialHasher

        + GetComponentDeps() []string
        + LinkWorld(w *World) 
        + Update(dt_ms float64) 
        + Expand(n int) 

    }
    class SpatialHasher << (S,Aquamarine) >> {
        - tableMutexes [][]sync.Mutex
        - capacity int

        + SpatialEntities *UpdatedEntityList
        + GridX int
        + GridY int
        + CellSizeX float64
        + CellSizeY float64
        + Table [][][]*Entity

        - allocTable() 
        - allocTableMutexes() 
        - parallelUpdateC() 
        - singleThreadUpdate() 
        - clearTable() 
        - scanAndInsertEntitiesparallelC() 
        - scanAndInsertEntitiesSingleThread() 

        + Entities(x int, y int) []*Entity
        + Update() 
        + CellRangeOfRect(pos Vec2D, box Vec2D) (int, int, int, int)
        + TableCopy() [][][]*Entity
        + GetCellPosAndBox(x int, y int) (Vec2D, Vec2D)
        + CellsWithinDistance(pos Vec2D, box Vec2D, d float64) [][]int
        + CellsWithinDistanceApprox(pos Vec2D, box Vec2D, d float64) [][]int
        + EntitiesWithinDistanceApprox(pos Vec2D, box Vec2D, d float64) []*Entity
        + EntitiesWithinDistanceApproxFilter(pos Vec2D, box Vec2D, d float64, predicate <font color=blue>func</font>(*Entity) bool) []*Entity
        + EntitiesWithinDistance(pos Vec2D, box Vec2D, d float64) []*Entity
        + EntitiesWithinDistanceFilter(pos Vec2D, box Vec2D, d float64, predicate <font color=blue>func</font>(*Entity) bool) []*Entity
        + String() string
        + Expand(n int) 

    }
    class Sprite << (S,Aquamarine) >> {
        + Texture *sdl.Texture
        + Frame uint8
        + Visible bool
        + Flip sdl.RendererFlip

    }
    class SpriteSystem << (S,Aquamarine) >> {
        - w *World

        + SpriteEntities *UpdatedEntityList
        + Textures <font color=blue>map</font>[string]*sdl.Texture
        + NilTexture *sdl.Texture

        - generateNilTexture(renderer *sdl.Renderer) 

        + GetSprite(name string) Sprite
        + LoadFiles(renderer *sdl.Renderer) 
        + GetComponentDeps() []string
        + LinkWorld(w *World) 
        + Update(dt_ms float64) 
        + Expand(n int) 

    }
    class SteeringSystem << (S,Aquamarine) >> {
        - w *World
        - movementEntities *UpdatedEntityList

        + GetComponentDeps() []string
        + LinkWorld(w *World) 
        + Update(dt_ms float64) 
        + Seek(e *Entity) 
        + Apply(e *Entity) 
        + Expand(n int) 

    }
    class SubscriberList << (S,Aquamarine) >> {
        - channels <font color=blue>map</font>[string][]*EventChannel

    }
    interface System  {
        + LinkWorld(w *World) 
        + Update(dt_ms float64) 
        + GetComponentDeps() []string
        + Expand(n int) 

    }
    class TagList << (S,Aquamarine) >> {
        - tags <font color=blue>map</font>[string]bool
        - dirty bool
        - slice []string

        + Length() int
        + Has(tags ...string) bool
        + Add(tags ...string) 
        + MergeIn(l2 TagList) 
        + Remove(tag string) 
        + CopyOf() TagList
        + AsSlice() []string
        + MarshalJSON() ([]byte, error)

    }
    class TimeAccumulator << (S,Aquamarine) >> {
        - accum_ms float64
        - period_ms float64

        + Tick(dt_ms float64) bool
        + Completion() float64

    }
    class UpdatedEntityList << (S,Aquamarine) >> {
        - entities []*Entity
        - sorted bool
        - callbacks []<font color=blue>func</font>(EntitySignal) 

        + Filter *EntityFilter

        - add(e *Entity) 
        - remove(e *Entity) 

        + Signal(signal EntitySignal) 
        + AddCallback(callback <font color=blue>func</font>(EntitySignal) ) 
        + Length() int
        + GetEntities() []*Entity
        + FirstEntity() (*Entity, error)
        + RandomEntity() (*Entity, error)
        + String() string

    }
    class Vec2D << (S,Aquamarine) >> {
        + X float64
        + Y float64

        + Inc(v2 Vec2D) 
        + Add(v2 Vec2D) Vec2D
        + Sub(v2 Vec2D) Vec2D
        + Distance(v2 Vec2D) (float64, float64, float64)
        + ScalarCross(v2 Vec2D) float64
        + Dot(v2 Vec2D) float64
        + Magnitude() float64
        + Project(v2 Vec2D) float64
        + PerpendicularUnit() Vec2D
        + Scale(r float64) Vec2D
        + Unit() Vec2D
        + Truncate(val float64) Vec2D
        + XComponent() Vec2D
        + YComponent() Vec2D
        + AngleBetween(v2 Vec2D) float64
        + ShiftedCenterToBottomLeft(box Vec2D) Vec2D
        + ShiftedBottomLeftToCenter(box Vec2D) Vec2D
        + ShiftCenterToBottomLeft(box Vec2D) 
        + ShiftBottomLeftToCenter(box Vec2D) 

    }
    class WindowSpec << (S,Aquamarine) >> {
        + Title string
        + Width int
        + Height int
        + Fullscreen bool

    }
    class World << (S,Aquamarine) >> {
        - em *EntityManager
        - systems <font color=blue>map</font>[string]System
        - systemsIDs <font color=blue>map</font>[System]int
        - worldLogics <font color=blue>map</font>[string]*LogicUnit
        - funcs *FuncSet
        - blackboards <font color=blue>map</font>[string]*Blackboard
        - totalRuntimeAvg_ms *float64

        + Seed int
        + Width float64
        + Height float64
        + IdGen *IDGenerator
        + Events *EventBus
        + RuntimeSharer *RuntimeLimitSharer
        + SpatialHasher *SpatialHasher

        - addSystem(s System) 
        - assertSystemTypeValid(t reflect.Type) 
        - linkSystemDependencies(s System) 
        - addEntityLogic(e *Entity, l *LogicUnit) *LogicUnit
        - removeEntityLogic(e *Entity, l *LogicUnit) 

        + Update(allowance_ms float64) float64
        + RegisterComponents(specs ...string) 
        + RegisterCCCs(customs []CustomContiguousComponent) 
        + RegisterSystems(systems ...System) 
        + SetSystemSchedule(systemName string, period_ms float64) 
        + AddWorldLogic(Name string, F <font color=blue>func</font>(float64) ) *LogicUnit
        + AddWorldLogicWithSchedule(Name string, F <font color=blue>func</font>(float64) , period_ms float64) *LogicUnit
        + RemoveWorldLogic(Name string) 
        + ActivateAllWorldLogics() 
        + DeactivateAllWorldLogics() 
        + ActivateWorldLogic(name string) 
        + DeactivateWorldLogic(name string) 
        + RemoveAllEntityLogics(e *Entity) 
        + ActivateAllEntityLogics() 
        + DeactivateAllEntityLogics() 
        + ActivateEntityLogics(e *Entity) 
        + DeactivateEntityLogics(e *Entity) 
        + AddFuncs(funcs <font color=blue>map</font>[string]) 
        + AddFunc(name string, f <font color=blue>func</font>(<font color=blue>interface</font>{}) <font color=blue>interface</font>{}) 
        + RemoveFunc(name string) 
        + GetFunc(name string) <font color=blue>func</font>(<font color=blue>interface</font>{}) <font color=blue>interface</font>{}
        + HasFunc(name string) bool
        + Blackboard(name string) *Blackboard
        + String() string
        + DumpStats() <font color=blue>map</font>[string]
        + DumpStatsString() string
        + MaxEntities() int
        + Components() *ComponentTable
        + Spawn(spec <font color=blue>map</font>[string]any) *Entity
        + QueueSpawn(spec <font color=blue>map</font>[string]any) 
        + QueueDespawn(e *Entity) 
        + Despawn(e *Entity) 
        + DespawnAll() 
        + Activate(e *Entity) 
        + Deactivate(e *Entity) 
        + GetUpdatedEntityList(q EntityFilter) *UpdatedEntityList
        + GetSortedUpdatedEntityList(q EntityFilter) *UpdatedEntityList
        + GetUpdatedEntityListByName(name string) *UpdatedEntityList
        + GetUpdatedEntityListByComponentNames(names []string) *UpdatedEntityList
        + UniqueTaggedEntity(tag string) (*Entity, error)
        + UpdatedEntitiesWithTag(tag string) *UpdatedEntityList
        + EntityHasComponent(e *Entity, name string) bool
        + EntityHasTag(e *Entity, tag string) bool
        + TagEntity(e *Entity, tags ...string) 
        + TagEntities(entities []*Entity, tag string) 
        + UntagEntity(e *Entity, tag string) 
        + UntagEntities(entities []*Entity, tag string) 
        + NumEntities() (int, int)
        + GetActiveEntitiesSet() <font color=blue>map</font>[*Entity]bool
        + GetCurrentEntitiesSet() <font color=blue>map</font>[*Entity]bool
        + GetCurrentEntitiesSetCopy() <font color=blue>map</font>[*Entity]bool
        + DumpEntities() string
        + PredicateAllEntities(p <font color=blue>func</font>(*Entity) bool) []*Entity
        + PredicateEntities(entities []*Entity, p <font color=blue>func</font>(*Entity) bool) []*Entity
        + EntitiesWithTags(tags ...string) []*Entity
        + ActiveEntitiesWithTags(tags ...string) []*Entity
        + EntitiesWithinDistance(pos Vec2D, box Vec2D, d float64) []*Entity
        + EntitiesWithinDistanceFilter(pos Vec2D, box Vec2D, d float64, filter <font color=blue>func</font>(*Entity) bool) []*Entity
        + EntitiesWithinDistanceApprox(pos Vec2D, box Vec2D, d float64) []*Entity
        + EntitiesWithinDistanceApproxFilter(pos Vec2D, box Vec2D, d float64, filter <font color=blue>func</font>(*Entity) bool) []*Entity
        + CellsWithinDistance(pos Vec2D, box Vec2D, d float64) [][]int
        + CellsWithinDistanceApprox(pos Vec2D, box Vec2D, d float64) [][]int

    }
    class WorldSpec << (S,Aquamarine) >> {
        + Width int
        + Height int
        + DistanceHasherGridX int
        + DistanceHasherGridY int

    }
    class curves << (S,Aquamarine) >> {
        + Bell(spread float64) CurveFunc
        + Sigmoid(x float64) float64
        + Quadratic(x float64) float64
        + Linear(x float64) float64
        + Greater(b float64) CurveFunc
        + Less(b float64) CurveFunc
        + Interval(a float64, b float64) CurveFunc
        + Clamped(x float64) float64

    }
    class sameriver.CurveFunc << (T, #FF7700) >>  {
    }
    class sameriver.EntitySignalType << (T, #FF7700) >>  {
    }
    class sameriver.GOAPPriorityQueue << (T, #FF7700) >>  {
    }
    class sameriver.RenderFunc << (T, #FF7700) >>  {
    }
    class testDependentNonPointerSystem << (S,Aquamarine) >> {
        - ts testNonPointerReceiverSystem

        + LinkWorld(w *World) 
        + Update(dt_ms float64) 
        + GetComponentDeps() []string
        + Expand(n int) 

    }
    class testDependentNonSystemSystem << (S,Aquamarine) >> {
        - ts *EntityManager

        + LinkWorld(w *World) 
        + Update(dt_ms float64) 
        + GetComponentDeps() []string
        + Expand(n int) 

    }
    class testDependentSystem << (S,Aquamarine) >> {
        - ts *testSystem

        + LinkWorld(w *World) 
        + Update(dt_ms float64) 
        + GetComponentDeps() []string
        + Expand(n int) 

    }
    class testNonPointerReceiverSystem << (S,Aquamarine) >> {
        + LinkWorld(w *World) 
        + Update(dt_ms float64) 
        + GetComponentDeps() []string
        + Expand(n int) 

    }
    class testSystem << (S,Aquamarine) >> {
        - updates int

        + LinkWorld(w *World) 
        + Update(dt_ms float64) 
        + GetComponentDeps() []string
        + Expand(n int) 

    }
    class testSystemThatIsMisnamed << (S,Aquamarine) >> {
        + LinkWorld(w *World) 
        + Update(dt_ms float64) 
        + GetComponentDeps() []string
        + Expand(n int) 

    }
    class testingGameScene << (S,Aquamarine) >> {
        - accum_ms float64
        - initRan bool
        - updateRan bool
        - drawRan bool
        - handleKeyboardStateRan bool
        - handleKeyboardEventRan bool
        - nextSceneRan bool

        + Name() string
        + Init(game *Game, config <font color=blue>map</font>[string]string) 
        + Update(dt_ms float64, allowance_ms float64) 
        + Draw(window *sdl.Window, renderer *sdl.Renderer) 
        + HandleKeyboardState(keyboard_state []uint8) 
        + HandleKeyboardEvent(keyboard_event *sdl.KeyboardEvent) 
        + IsDone() bool
        + NextScene() Scene
        + End() 
        + IsTransient() bool
        + Destroy() 

    }
    class testingLoadingScene << (S,Aquamarine) >> {
        - initRan bool
        - updateRan bool
        - drawRan bool
        - handleKeyboardStateRan bool
        - handleKeyboardEventRan bool
        - nextSceneRan bool

        + Name() string
        + Init(game *Game, config <font color=blue>map</font>[string]string) 
        + Update(dt_ms float64, allowance_ms float64) 
        + Draw(window *sdl.Window, renderer *sdl.Renderer) 
        + HandleKeyboardState(keyboard_state []uint8) 
        + HandleKeyboardEvent(keyboard_event *sdl.KeyboardEvent) 
        + IsDone() bool
        + NextScene() Scene
        + End() 
        + IsTransient() bool
        + Destroy() 

    }
    class "<font color=blue>func</font>(*sdl.Window, *sdl.Renderer) " as fontcolorbluefuncfontsdlWindowsdlRenderer {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}

"sameriver.System" <|-- "sameriver.CollisionSystem"
"sameriver.EntityManagerInterface" <|-- "sameriver.EntityManager"
"sameriver.System" <|-- "sameriver.InventorySystem"
"sameriver.System" <|-- "sameriver.ItemSystem"
"sameriver.System" <|-- "sameriver.PhysicsSystem"
"sameriver.System" <|-- "sameriver.SpatialHashSystem"
"sameriver.System" <|-- "sameriver.SpriteSystem"
"sameriver.System" <|-- "sameriver.SteeringSystem"
"sameriver.EntityManagerInterface" <|-- "sameriver.World"
"sameriver.System" <|-- "sameriver.testDependentNonPointerSystem"
"sameriver.System" <|-- "sameriver.testDependentNonSystemSystem"
"sameriver.System" <|-- "sameriver.testDependentSystem"
"sameriver.System" <|-- "sameriver.testNonPointerReceiverSystem"
"sameriver.System" <|-- "sameriver.testSystem"
"sameriver.System" <|-- "sameriver.testSystemThatIsMisnamed"
"sameriver.Scene" <|-- "sameriver.testingGameScene"
"sameriver.Scene" <|-- "sameriver.testingLoadingScene"

"__builtin__.int" #.. "sameriver.EntitySignalType"
"sameriver.fontcolorbluefuncfontsdlWindowsdlRenderer" #.. "sameriver.RenderFunc"
"sameriver.<font color=blue>func</font>(float64) float64" #.. "sameriver.CurveFunc"
"sameriver.[]*GOAPPQueueItem" #.. "sameriver.GOAPPriorityQueue"
@enduml
