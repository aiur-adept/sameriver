package main

import (
	"fmt"
	"io"
	"os"
	"strings"
)

func generateSwitchStatementCore(funcReturnType, switchFuncName, userRegisterFunc string, typesStr string) string {
	types := strings.Split(typesStr, ",")
	typePermutations := [][]string{}

	// Generate permutations with repetitions of length 1, 2, and 3
	for i := 1; i <= 3; i++ {
		typePermutations = append(typePermutations, permutationsWithRepetitions(types, i)...)
	}

	var cases []string

	for _, permutation := range typePermutations {
		caseStr := fmt.Sprintf("\tcase func(%s) %s:", strings.Join(permutation, ", "), funcReturnType)
		args := make([]string, len(permutation))
		for i, argType := range permutation {
			args[i] = fmt.Sprintf("argsTyped[%d].(%s)", i, argType)
		}
		caseStr += fmt.Sprintf("\n\t\tresult = fTyped(%s)", strings.Join(args, ", "))
		cases = append(cases, caseStr)
	}

	return fmt.Sprintf(`func (e *EntityFilterDSLEvaluator) %s(f any, argsTyped []any) %s {
	var result %s
	switch fTyped := f.(type) {
%s
	default:
		panic("No case in either engine or user-registered signatures for the given func. Use EFDSL.%s()")
	}

	return result
}`, switchFuncName, funcReturnType, funcReturnType, strings.Join(cases, "\n"), userRegisterFunc)
}

func generatePredicateSwitchStatement(typesStr string) string {
	return generateSwitchStatementCore("func(*Entity) bool", "predicateSignatureAssertSwitch", "RegisterUserPredicateSignatureAsserter", typesStr)
}

func generateSortSwitchStatement(typesStr string) string {
	return generateSwitchStatementCore("func(xs []*Entity) func(i, j int) int", "sortSignatureAssertSwitch", "RegisterUserSortSignatureAsserter", typesStr)
}

func main() {
	fmt.Println("sameriver-efdsl-gen (extremely f***** delicious spaghetti lasagna!)")

	types := "bool,int,string,*Entity,[]*Entity,*Vec2D,[]*Vec2D"
	predicateSwitches := generatePredicateSwitchStatement(types)
	sortSwitches := generateSortSwitchStatement(types)

	commentWarning := `/*
Heed this warning. Do not edit this file by hand; instead use sameriver-efdsl-gen. And yes, it is horrifying. Blame Rob Pike! My revenge is allowing overloading of predicate/sort signatures.
*/`

	code := "package sameriver\n\n" + commentWarning + "\n\n" + predicateSwitches + "\n\n" + sortSwitches

	file, err := os.Create("GENERATED_efdsl_sig_assert_switches.go")
	if err != nil {
		fmt.Printf("Error creating file: %v\n", err)
		return
	}
	defer file.Close()

	_, err = io.WriteString(file, code)
	if err != nil {
		fmt.Printf("Error writing to file: %v\n", err)
	}

}

func permutationsWithRepetitions(elements []string, length int) [][]string {
	if length == 1 {
		result := make([][]string, len(elements))
		for i, element := range elements {
			result[i] = []string{element}
		}
		return result
	}

	previousPermutations := permutationsWithRepetitions(elements, length-1)
	result := [][]string{}
	for _, element := range elements {
		for _, previousPermutation := range previousPermutations {
			result = append(result, append(previousPermutation, element))
		}
	}

	return result
}
