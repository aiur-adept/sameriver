



remainings [[u]]
regionOffets [[0]]

now we want to insert C at 0 to satisfy remainings[0][0] = u
i = 0
regionIx = 0
insertionIx = 0


path [C]
remainings [[s t] [u]]
regionOffets [[0 0] [0]]

path [B C]
remainings [[r] [s t] [u]]
regionOffsets [[0] [-1 0] [0]]

now we want to insert A at 0 to satisfy remainings[1][0] = s
i = 1
regionIx = 0
insertionIx = 0  // HOW DO WE COMPUTE?

we should compare if [A] satisfies s better than []

path [A B C]
remainings [[q] [r] [s t] [u]]
regionOffsets [[0] [0] [-1 0] [0]]





let's say we had

path [A C]
remainings [[q] [s t] [u]]
regionOffsets [[0] [0 0] [0]]

now we want to insert B at 1 to satisfy remainings[1][1] = t
i = 1
regionIx = 1
insertionIx = 1 // HOW DO WE COMPUTE?

we should compare if [A B] satisfies t better than [A]

stateAtPoint = path.statesAlong[insertionIx] = path.statesAlong[1] (result of [A])
















i'm writing a GOAP game-ai plan solver, in which we build up a chain of actions working backward from the end goal according to actions fulfilling certain conditions. we begin by putting in an action that fulfills the end condition, then we insert its preconditions to be satisfied.

So, if we have goal list [u] and C satsifes u and has preconditions [s t] (it wants s to be satisfied first in temporal order, then t), we would end up with the path

[C]

and the new goal surface of 

[s t u]

where u has been satisfied, and s and t are yet to be fulfilled by inserting some other actions.

here is an example trace working toward the end path of [X, A, Y, B, C]

```
example trace:
	
	start goal = remainings: [u]
	C has pre [s t] and fulfills u
	insert C at 0 (i = 0; region = 0)
	   path: [C]

	remainings: [s t u]
	A has pre [q] and fulfills s
	insert A at 0 (i = 0; region = 0)
	    path: [A C]

	remainings [q s t u]
	B has pre [r] and fulfills t
	insert B at 1 (i = 2; region = 0)
	   path: [A, B, C]

	remainings: [q s r t u]
	X has pre [] and fulfills q
	insert X at 0 (i = 0; region = 0)
	   path: [X, A, B, C]

	remainings: [q s r t u]
	Y has pre [] and fulfills r
	insert Y at 2 (i = 2; region = 0)
	   path: [X, A, Y, B, C]

	remainings: [q s r t u]
	complete
```

C has a temporally-ordered precondition [s t] meaning we want to insert the satisfying chain for s in order *before* the satisfying chain for t. 

X and Y have no preconditions
A and B have preconditions of only one temporal zone, [q] and [r] respectively.

As you can see, the fact that C has a *temporally ordered* precondition means that we can imagine two "regions" in the list ahead of C. Initially, when the path is [C], the regions are [] [], but when we insert A, we have regions [A] []. Then when we insert B, we have regions [A], [B].

The thing is, the precondition list is flattened. When the path is [C] we simply have the remainings: [s t u]. And we iterate this with index i.

Let's say we went through the paths:

[C]
[B C]
[A B C]
[X A B C]

with resulting remainings:

[q s r t u]

When we want to insert the satisfying action for r (that is, Y), we need to insert at index 2 in the path, resulting in [X A Y B C], but in iterating the flattened precondition array, we are at i = 2 for condition r.

It seems as though we need to somehow keep track of the (nested) region offsets for the flattened conditions, such that we will know [X A] (length 2) has been inserted in region 0 of [s t], and [B] has been inserted at region 1 of [s t].

How might we keep track of this information? Keep in mind that it should be updated whenever we make an insertion, and there may be *nested* temporal regions. If in our example, B to satisfy t had its own nested preconditions [m n], and the path was

[A, B, C]

we would have to insert appropriately given a flat precondition list of 

[q s m n t u]




i think it more naturally corresponds to a kind of tree, where each precondition keeps track of 

its own region offsets

a link to its parent condition (the condition whose sastisfying action this is a precondition of)

does that make sense? then we would resolve the index of insertion by traversing upward from the leaf, and when we insert, we would cascade modifications down from the top wherever needed



the tree for 

path: [A, B, C]
remainings: [q s m n t u]

would be:

 u
|  \
s   t
|   |  \
q   m   n



where u (corresponding to insertion before C) has regionOffsets [-1, 0]

s (corresponding to insertion before A) has regionOffsets [0]

t (corresponding to insertion before B) has regionOffsets [0, 0]

if we were to insert X to satisfy m,

resulting in 

[A, X, B, C]

then t would have regionOffets [-1, 0]

and u would be updated to have regionOffsets [-2, 0]






































goal


path.path:

[]

path.remainings:

       main
        |
[ (woodChopped) ]

path.regionOffsets

[ (0) ]

i = 0
consider remainings[i] (woodChopped)
considering actions for woodChopped (region 0)
insert at 0 - 0 (i + path.regionOffsets[i][region])
    [ chopTree ]


path.path:

[ chopTree ]

path.remainings:

            chopTree                 main
   ________________________           |
  /                        \          |
[ (hasGlove,hasAxe), (atTree), (woodChopped) ]

path.regionOffsets:

[ (0 0) (0) ]

i = 0
consider remainings[i] (hasGlove,hasAxe)
consider actions for hasGlove,hasAxe (region0)
insert at 0 - 0  (i + path.regionOffsets[0])
[ getGlove, chopTree ]
[ getAxe , chopTree ]

i = 1
consider actions for atTree (region1)
insert at 0 (i + tg.regionOffsets[1])
[ goToTree, chopTree ]



path:

[ goToTree, chopTree ]

remainings:

            chopTree                 main
   ________________________           |
  /                        \          |
[ (hasGlove, hasAxe), (atTree), (woodChopped) ]

i = 0
consider actions for hasGlove,hasAxe (region0)
insert at 0 - 0 (i + tg.regionOffsets[0])
[ getGlove, goToTree, chopTree ]
[ getAxe, goToTree, chopTree ]



path:

[ getGlove, chopTree ]

remainings:

[ (atGlove), (hasGlove,hasAxe), (atTree), (woodChopped) ]

i = 0
consider actions for atGlove
insert at 0 - 0 (i + tg.regionOffsets[0])
[ goToGlove, getGlove, chopTree ]

i = 1
consider actions for hasGlove,hasAxe
insert at 1 - 0 (i + tg.regionOffsets[0])
[ getGlove, getAxe, chopTree ]

i = 2
consider 




for i, g := range here.path.remainings.surface {
    if g.nUnfulfilled == 0 {
        continue
    }
    for _, regionGoalLeft := range g.goalLeft {
        for varName := range regionGoalLeft {
            for action := range p.eval.varActions[varName] {
                scale, helpful := p.eval.actionHelpsToInsert(start, here.path, i, action)
                if helpful {
                    var toInsert *GOAPAction
                    if scale > 1 {
                        toInsert = action.Parametrized(scale)
                    } else {
                        toInsert = action
                    }
                    newPath := here.path.inserted(toInsert, i)
                    pathStr := newPath.String()
                    if _, ok := pathsSeen[pathStr]; ok {
                        continue
                    } else {
                        pathsSeen[pathStr] = true
                    }
                    p.eval.computeRemainingsOfPath(newPath, start, goal)
                    pq.Push(&GOAPPQueueItem{path: newPath})
                }
            }
        }
    }
}
