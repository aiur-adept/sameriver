



parametrized actions (numeric)

if we want to solve drunk>2, we determine if drink itself helps.
if does; so we divide the diff by action.eff.val and that's how many times to run the action.
we prepend drink(3), and its pres are also parametrically scaled:

    hasBooze,>= 3

similarly, for woodChopped = 3, we determine if chopWood helps
it does; so we divide the diff by action.eff.val and that's how many times to run the action.
we prepend chopWood(3), and its pres are parametrically scaled:

    (notice: none are scaled!)

    hasAxe,=: 1
    hasGlove,=: 1
    atTree,=: 1


how to distinguish what should scale and what shouldn't?

drink
    pres:
        EACH:hasBooze,>=: 1

chopWood
    pres:
        hasAxe,=: 1
        hasGlove,=: 1
        atTree,=: 1

[x] action has .Count field
[x] action name becomes Name() which uses fmt.Sprintf
[ ] in prepending, if helpful, we calculate the count necessary and prepend the parametrized action
[x] when an action is parametrized with a count, it creates the scaled pre goal
[_] in appending pres, we proceed as normal since the pre is already scaled









goal: drunk > 2


[]

consider prepending [drink]

helps drunk!

new path [drink]
{drunk: 0} -> {drunk: 1}

remaining:
main: drunk > 2
pres: [hasBooze>0]


*don't evaluate modals during deepening, during evaluating remainings of paths*
*don't evaluate modals til validateForward when a possible solution is found*
(if we were to evaluate the modal for drink, we'd try to remove a hasbooze that isn't available)




              [drink, drink, drink]

main: nil
pres: [hasBooze>0, hasBooze>0, hasBooze>0] (because, these pres were not satisfied during runthrough)

consider prepending [getBooze]

satisfies pre[0]

new remaining:

main: nil
pres: [nil, hasBooze>0, hasBooze>0]































TODO:
when evaluating a path, populate start according to which modal vals *appear in the effs and checks*







before: [drink, dropAllBooze, purifyOneself, enterTemple]
    pres: [drinkpre, dropAllBoozePre, purifyOneselfPre, enterTemplePre]

after: [drink, drink, dropAllBooze, purifyOneself, enterTemple]
    pres: [drinkPre, drinkpre, dropAllBoozePre, purifyOneselfPre, enterTemplePre]

if pathConstruction = GOAP_PATH_PREPEND,
    for i = 1; i < len(after.pres); i++
        compare after.pres[i] with before.pres[i-1]


before: [openFridge, getFood]
    pres: [openFridgePre, getFoodPre]

after: [openFridge, getFood, closeFridge]
    pres: [openFridgePre, getFoodPre, closeFridgePre]

if pathConstruction = GOAP_PATH_APPEND

    for i = 0; i < len(before.pres); i++
        compare after.pres[i] with before.pres[i]







responsible fridge usage:

start state: [hasFood: 0, fridgeOpen: 0]

    *   in below, when we "run path and compute remaining",
        we also compute the remaining for each action's
        pre as it is reached in the list; this is used when
        we "iterate path action pres"


start with
    path: []
    run path and compute remaining:
        goals: [hasFood = 1]

    consider fulfilling: main
        prepend/append any action that fulfills main better than result of path ([])
            (getFood)

    new path: [getFood]

next iter
    path: [getFood]
    run path and compute remaining:
        goals: []

    consider fulfilling: main
        no unfulfilled main goals

    iterate path action pres:
        consider getFood pres:
            (openFridge) fulfills pre

    new path: [openFridge, getFood]

next iter:
    path: [openFridge, getFood]
    run path and compute remaining:
        goals: [fridgeClosed: 0]

    consider fulfilling: main
        prepend/append any action that fulfills main better than result of path
            (closeFridge end state fulfills main better as append (does not as prepend))

    iterate path action pres:
        all actions pres are fulfilled in course of path (openFridge, getFood)

    new paths:

    [openFridge, getFood, closeFridge]

next iter:
    path: [openFridge, getFood, closeFridge]
    run path and compute remaining:
        goals: []

    consider fulfilling: main
        all fulfilled

    iterate path action pres:
        all actions pres are fulfilled in course of path (openFridge, getFood, closeFridge)

    therefore, solution found!





alan watts simulator:

start state: [hasBooze: 3, drunk: 0, admittedToTemple: 0]

start with
    path: []
    run path and compute remaining:
        goals: [drunk: 3, admittedToTemple: 1]

    consider fulfilling: main
        prepend/append any action that fulfills main better than result of path ([])
            (drink)
            (enterTemple)

    new paths:
        [drink]
        [enterTemple]

next iter
    path: [drink]
    run path and compute remaining:
        goals: [drunk: 3, admittedToTemple: 1]

    consider fulfilling: main
        prepend/append any action that fulfills main better than result of path ([drink])
            (drink)
            (enterTemple)

    iterate path action pres:
        consider drink pres:
            (hasBooze) start state fulfills, nothing to do

    new paths:
        [drink, drink]
        [drink, drink]
        [drink, enterTemple]
        [enterTemple, drink]

next iter:
    path: [enterTemple]
    run path and compute remaining:
        goals: [drunk: 3]

    consider fulfilling: main
        prepend/append any action that fulfills main better than result of path
            (drink)

    iterate path action pres:
        consider enterTemple pres:
            (purifyOneself) fulfills pre

    new paths:

    [drink, enterTemple]
    [purifyOneself, enterTemple]

next iter:
    path: [purifyOneself, enterTemple]
    run path and compute remaining:
        goals: [drunk: 3]

    consider fulfilling: main
        prepend/append any action that fulfills main better than result of path
            (drink)

    iterate path action pres:
        consider purifyOneself:
            (dropAllBooze) fulfills pre

    new paths:

    [drink, purifyOneself, enterTemple]
    [dropAllBooze, purifyOneself, enterTemple]
























eval.admissiblePrependingAction(start, action, goal)
    - for each goal
        - for each var
            given spec:
            - if = spec, does action set varname = target?
            - if < or <= spec, does action subtract?
            - if > or >= spec, does action add?
                true:
                - prepend, evaluate path, update goal frontier
                false:
                - not a useful action
