
//
//
// THIS FILE HAS BEEN GENERATED BY sameriver-generate
//
//
// DO NOT MODIFY BY HAND UNLESS YOU WANNA HAVE A GOOD TIME WHEN THE NEXT
// GENERATION DESTROYS WHAT YOU WROTE. UNLESS YOU KNOW HOW TO HAVE A GOOD TIME
//
//

package engine

import (
	"errors"
	"fmt"
	"github.com/veandco/go-sdl2/sdl"
)

// read an entity's Box by read-locking the value
// this is safe at any time, in any logic goroutine
func (ct *ComponentsTable) ReadBox(e EntityToken) (sdl.Rect, error) {
	// lock the entity's component value as a reader, and
	// check the gen is valid once we have the lock.
	// (release if not valid, returning error)
	ct.em.rLockEntityComponent(e, BOX_COMPONENT)
	defer ct.em.rUnlockEntityComponent(e, BOX_COMPONENT)
	if !ct.em.entityTable.genValidate(e) {
		// if genValidate failed, return an error
		// we use the first element of the component data
		// simply because it's of the right type.
		return ct.Box[0], errors.New(fmt.Sprintf("%+v no longer exists", e))
	}
	return ct.Box[e.ID], nil
}

// read an entity's Sprite by read-locking the value
// this is safe at any time, in any logic goroutine
func (ct *ComponentsTable) ReadSprite(e EntityToken) (Sprite, error) {
	// lock the entity's component value as a reader, and
	// check the gen is valid once we have the lock.
	// (release if not valid, returning error)
	ct.em.rLockEntityComponent(e, SPRITE_COMPONENT)
	defer ct.em.rUnlockEntityComponent(e, SPRITE_COMPONENT)
	if !ct.em.entityTable.genValidate(e) {
		// if genValidate failed, return an error
		// we use the first element of the component data
		// simply because it's of the right type.
		return ct.Sprite[0], errors.New(fmt.Sprintf("%+v no longer exists", e))
	}
	return ct.Sprite[e.ID], nil
}

// read an entity's TagList by read-locking the value
// this is safe at any time, in any logic goroutine
func (ct *ComponentsTable) ReadTagList(e EntityToken) (TagList, error) {
	// lock the entity's component value as a reader, and
	// check the gen is valid once we have the lock.
	// (release if not valid, returning error)
	ct.em.rLockEntityComponent(e, TAGLIST_COMPONENT)
	defer ct.em.rUnlockEntityComponent(e, TAGLIST_COMPONENT)
	if !ct.em.entityTable.genValidate(e) {
		// if genValidate failed, return an error
		// we use the first element of the component data
		// simply because it's of the right type.
		return ct.TagList[0], errors.New(fmt.Sprintf("%+v no longer exists", e))
	}
	/*
	   get the TagList with deepcopy, since DeepCopyTagList() was specified.
	   (a DeepCopy method should be specified whenever the component value
	   returned may change as a receiver is reading it, after it's been
	   retrieved from the component data table)
	*/
	return DeepCopyTagList(ct.TagList[e.ID]), nil
}

// read an entity's Velocity by read-locking the value
// this is safe at any time, in any logic goroutine
func (ct *ComponentsTable) ReadVelocity(e EntityToken) ([2]float32, error) {
	// lock the entity's component value as a reader, and
	// check the gen is valid once we have the lock.
	// (release if not valid, returning error)
	ct.em.rLockEntityComponent(e, VELOCITY_COMPONENT)
	defer ct.em.rUnlockEntityComponent(e, VELOCITY_COMPONENT)
	if !ct.em.entityTable.genValidate(e) {
		// if genValidate failed, return an error
		// we use the first element of the component data
		// simply because it's of the right type.
		return ct.Velocity[0], errors.New(fmt.Sprintf("%+v no longer exists", e))
	}
	return ct.Velocity[e.ID], nil
}
